% document
\documentclass[10pt,graphics,aspectratio=169,table]{beamer}
\usepackage{../code}
\usepackage{csquotes}
\usepackage{hyperref}

% theme
\usetheme{metropolis}
% packages
\title{Lesson 2}
\author{Christian Schwarz, Jakob Krebs}
\date{04.11.2019}
\begin{document}
\maketitle

\begin{frame}{Contents}
    \tableofcontents
\end{frame}


\section{Source Code and Solutions}
\begin{frame}{Sources and Solutions}
    \begin{itemize}
        \item we publish all code written in this course at \url{https://github.com/jkrbs/c_lessons}
        \item we will publish example solutions of the tasks on same site
        \item send us questions or your solutions to c-lessons@deutschland.gmbh
    \end{itemize}
\end{frame}
\section{Variables and Types}
    \begin{frame}{Integers}
    \begin{itemize}
        \item Keywords: \code{int}, \code{short}, \code{long}, \code{long long}
        \item Stored as a binary number with fixed length
        \item Can be \code{signed} or \code{unsigned} (undefined, but can be overridden using signed char and unsigned char)
        \item Actual size of \code{int}, \code{short}, \code{long} depends on architecture
        \item For definite sizes: include stddef.h which adds types like \code{size_t}, \code{int32_t}, \code{uint64_t}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Floating Point Numbers}
    \begin{itemize}
        \item Keywords: \code{float}, \code{double}, \code{long double}
        \item Stored as specified in \textit{IEEE 754 Standard} TL;DR
        \item Special values for $\infty$, $-\infty$, NaN
        \item Useful for fractions and very large numbers
        \item Type a decimal point instead of a comma!
    \end{itemize}\ \\
    \ \\
    Example:
    \begin{codeblock}
float x = 0.125;             /* Precision: 7 to 8 digits */
double y = 111111.111111;    /* Precision: 15 to 16 digits */
    \end{codeblock}
\end{frame}
\begin{frame}[fragile]{Characters}
    \begin{itemize}
        \item Keyword: \code{char}
        \item Can be \code{signed}(default) or \code{unsigned}
        \item Size: 1 Byte (8 Bit) on almost every architecture
        \item Intended to represent a single character
        \item Stores its \textit{ASCII} number (e.g. 'A' $\Rightarrow$ 65)
    \end{itemize}\ \\
    \ \\
    You can define a \code{char} either by its ASCII number or by its symbol:
    \begin{codeblock}
char a = 65;
char b = 'A';    /* use single quotation marks */
    \end{codeblock}
\end{frame}

\section{format strings}
\begin{frame}{format strings}
    The format string determines how a value is interpreted in the \code{printf} 
    function family. Here are some of the available options: \\ \ \\
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{type} & \textbf{description} & \textbf{type of argument} \\\hline
        \%c & single character & char, int (if $<=$ 255) \\\hline
        \%d or \%i & decimal number & char, int \\\hline
        \%u & unsigned decimal number & unsigned char, unsigned int \\\hline
        \%X & hexadecimal number & char, int \\\hline
        \%ld & long decimal number & long \\\hline
        \%f & floating point number & float, double \\\hline
        \%s & string & const char* [more on this later] \\\hline
    \end{tabular}
\end{frame}

\section{Operators}
\begin{frame}[fragile]{Basic Binary Operators}
    \begin{itemize}
        \item \code{+}, \code{-} just behave as expected
        \item \code{*} means multiply, \code{/} means divide
        \item Operator precedence works mostly as expected.
        \item You can use parenthesess around expressions: \code{(3 + 4) * 7}
        \item \code{=} is the assignment operator.
        \begin{itemize}
            \item
                \code{x = 4;} means that future references to \code{x}
                will evaluate to \code{4}
            \item
                you cannot assign to arbitrary expressions:
                \code{(x + 1) = 17} is not legal, since \code{(x + 1)}
                is not assignable. A compile time error occurs.
        \end{itemize}
        \item \code{==} is the comparison operator.
            \code{4 == 4} evaluates to \code{true},
            \code{x * 0 == 1} evaluates to \code{false}
        \item
            \code{\%} is the modulus operator.
            Examples: \code{7 \% 3 == 1}, \code{2 \% 2 == 0}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Type Conversions}
    \begin{itemize}
        \item 
            Explicit type conversion can be performed using the casting syntax:
            \begin{codeblock}
int i = 5;
float fi = (float)i;
            \end{codeblock}
        \item 
            When mixing different types in an expression, C will convert the
            types to match. The rules applying here are rather complicated,
            please use explicit casts instead like this: 
            \begin{codeblock}
int i = 5;
float res = (float)i * 3;
            \end{codeblock}
        \item 
            Be especially wary of mixing \code{signed}
            and \code{unsigned} integers!
    \end{itemize}\ \\
    \ \\

\end{frame}

\section{Control Structures}
\begin{frame}[fragile]{if statements}
    \begin{itemize}
    \item basic usage:
        \begin{codeblock}
if(3 > 2){  // arbitrary condition
    //this gets executed IF the condition evaluates to true
}
        \end{codeblock}
    \item short form (use it only for short and simple things):
        \begin{codeblock}
if(3 > 2) bar();
        \end{codeblock}

    \item else blocks:
        \begin{codeblock}
if(foo()){
}
else if(bar()){
}
else{
}
        \end{codeblock}

        what we really use here is the shorthand notation on the else block

    \end{itemize}
\end{frame}

\begin{frame}[fragile]{switch statements}
    \begin{codeblock}
switch(command_that_returns_a_status_code()){
    case 0: break; //everything is ok
    case 1: puts("we ran out of disk space"); break;
    case 2: {
        puts("something terrible happened.");
        puts("have you tried switching it off and on again?");
    }break;
    case 17: puts("foo"); //fallthrough! missing break (or intended??)
    case 144: puts("bar"); break;
    default: puts("this should never happen(TM)");
}
    \end{codeblock}
    Every case must be terminated by a \code{break;} statement, otherwise the
    following case(s) also get executed. If this is really your intention,
    which happens very rarely, put a comment like \code{//fallthrough},
    since this is a common bug
\end{frame}

\begin{frame}[fragile]{basic while statements}
    \begin{codeblock}
int i = 0;
while(i < 20){
    printf("%i\n", i);
    i++;
}
    \end{codeblock}

    This loop prints the numbers from 0 to 19(inclusive).
    Before each iteration (even before the first) the condition is checked.
    Once the condition is no longer satisfied, it jumps after the loop block.
\end{frame}
\begin{frame}[fragile]{break and continue in while statements}
    \begin{codeblock}
int i = 0;
while(true){
    i++;
    if(i % 7 == 0) continue; //skip all numbers divisible by 5
    printf("%i\n", i);
    if(i == 20)break; //exit the loop once i is 20
}
    \end{codeblock}
    \begin{itemize}
        \item
            \code{continue} skips the rest of the loop block and begins
            the next iteration
        \item \code{break} just jumps after the end of the loop block
        \item
            Beware: if you have a \code{switch} inside a \code{while},
            \code{break} will just exit the \code{switch}!
        \item
            In fact, \code{break} and \code{continue} will always be applied to
            the innermost control structure that defines them.
    \end{itemize}
\end{frame}

\subsection{do \ldots while}

\begin{frame}[fragile]{do...while}
    The difference between \code{do...while} and \code{while} is the order of executing the statement(s) and checking the condition.\\
    \bigskip
    The \code{while} loop begins with checking, while the \code{do...while} loop begins with executing the statement(s).
    \begin{codeblock}
int i = 3;
do {
    - -i;
} while (i < 1);
\end{codeblock}
    \bigskip
    The Statement(s) in a \code{do...while} loop are executed at least once.
\end{frame}

\subsection{for loop}

\begin{frame}[fragile]{for}
    The For-Loop is comfortable for iterating. It takes three arguments.
    \begin{itemize}
        \item Initialization
        \item Condition
        \item Iteration statement
    \end{itemize}
    \bigskip
    For illustration, consider a program printing the numbers 1 to 10:
    \begin{codeblock}
for (int i = 1; i <= 10; ++i){
    printf("%d\n", i);
}
\end{codeblock}
    \begin{itemize}
        \item \textit{i} is called an \textit{index} iterating from the given start to a given end value
        \item \textit{i, j, k} are commonly used identifiers for the index
    \end{itemize}
\end{frame}

\section{Functions}
\begin{frame}[fragile]{Functions}
    \begin{itemize}
        \item
            a regular function has a return type, a name, parameters and a body
            \begin{codeblock}
int add(int a, int b){
    printf("%i + %i = %i\n", a, b, a + b);
    return a + b;
}
            \end{codeblock}
        \item 
            \code{printf} is also a function but the number of its arguments 
            can vary (\code{varargs}). we will talk about this later.
        \item
            a function can also return nothing,
            the type of \textit{"nothing"} is \code{void}.
        \item
            \code{void} returning functions should not 
            contain \code{return} statements
        \item 
            functions can call other functions 
            (including themselves, which is called recursion)
  
        \item 
            a function with no parameters should have \code{(void)} instead of 
            \code{()} as it's parameter specification,
            as C will otherwise treat the numer
            of parameters as undefined
            \begin{codeblock}
void foo(void){
    puts("I'm a very boring function :(");
}
            \end{codeblock}
    \end{itemize}

\end{frame}

\section{Complex Data Types}

\begin{frame}[fragile]{Enumerations}
    Oftentimes in Code you want to differentiate between a fixed set of Options.
    Using Integer values for this can get confusing very quickly. That's why
    C has \code{enum}, which can be thought of as restricted integer types 
    that alias certain integer values as constants.
    \begin{codeblock}
enum day_of_week{
    // if not specified, enum values are just the previous
    // value plus one, beginning at 0
    // we can override values if we want  
    MONDAY = 1,  
    TUESDAY, WEDNESDAY, THURSDAY,
    FRIDAY, SATURDAY, SUNDAY
}; // <- this trailing semicolon is necessary!

// this creates a variable called myday, whose value can
// be any of the enum elements whe defined above
enum day_of_week myday = TUESDAY; 
    \end{codeblock}
\end{frame}

\begin{frame}[fragile]{Enumerations in Switch Statements}
    Enumerations and switch statements often go hand in hand.
    They are also one of the cases where we can make good use of the
    fallthrough behaviour.
    \begin{codeblock}
switch(myday){
    case SATURDAY: 
    case SUNDAY: {
        puts("weekend :)");
    } break;
    default: {
        puts("its a weekday :("); 
    } break;
}
    \end{codeblock}
\end{frame}

\begin{frame}[fragile]{Structs}
    The basic building block of all data handling in C is the \code{struct}.
    Essentially it's just the idea to bundle up multiple variables as a reusable
    group. Like enums, structs are types and you can have variables of 
    that are \textbf{instances} of the struct.
    \begin{codeblock}
struct point{
    int x;
    int y;
}; // <- again, this trailing semicolon is necessary!

// this creates a variable called mypoint, which is an instance of
// the struct point
struct point mypoint;
    \end{codeblock}

    You can access elements of a struct using the \code{.} operator.
    \begin{codeblock}
mypoint.x = 3;
printf("\%i\n", mypoint.y);
    \end{codeblock}

    You can access elements of a struct using the \code{.} operator.
    \begin{codeblock}
mypoint.x = 3;
    \end{codeblock}
    
\end{frame}

\begin{frame}[fragile]{Shorthand Struct initialization}
    There exists a shorthand notation for creating instances of structs:
    \begin{codeblock}
        struct point{
            int x;
            int y;
        }; 
        
        //this specifies the names explicitly
        struct point myotherpoint = {x: 3, y: 5};

        // this depends on the order of the struct members
        struct point mypoint = {3, 5};
    \end{codeblock}

\end{frame}

\begin{frame}[fragile]{Structs and Enums in Functions}
    Structs and Enums can also be Function Parameters:
    \begin{codeblock}
void foo(enum day_of_week day, struct point p){ 
    //...
}
struct point p = {1,2};
//we can use enum values as literals, no need for a variable
foo(TUESDAY, p); 

// but this doesn't work, only use the struct shorthand
// for the initialization of variables !
foo(FRIDAY, {x: 1,y: 2}); //!!! compiler error
    \end{codeblock}
\end{frame}
  
\end{document}
