% document
\documentclass[10pt,graphics,aspectratio=169,table]{beamer}
\usepackage{../code}
\usepackage{csquotes}
\usepackage{hyperref}

% theme
\usetheme{metropolis}
% packages
\title{Lesson 3}
\author{Christian Schwarz, Jakob Krebs}
\date{04.11.2019}
\begin{document}
\maketitle

\begin{frame}{Contents}
    \tableofcontents
\end{frame}


\section{Source Code and Solutions}
\begin{frame}{Sources and Solutions}
    \begin{itemize}
        \item we publish all code written in this course at \url{https://github.com/jkrbs/c_lessons}
        \item we will publish example solutions of the tasks on same site
        \item send us questions or your solutions to c-lessons@deutschland.gmbh
    \end{itemize}
\end{frame}

\section{Complex Data Types}

\begin{frame}[fragile]{Enumerations}
    Oftentimes in Code you want to differentiate between a fixed set of Options.
    Using Integer values for this can get confusing very quickly. That's why
    C has \code{enum}, which can be thought of as restricted integer types 
    that alias certain integer values as constants.
    \begin{codeblock}
enum day_of_week{
    // if not specified, enum values are just the previous
    // value plus one, beginning at 0
    // we can override values if we want  
    MONDAY = 1,  
    TUESDAY, WEDNESDAY, THURSDAY,
    FRIDAY, SATURDAY, SUNDAY
}; // <- this trailing semicolon is necessary!

// this creates a variable called myday, whose value can
// be any of the enum elements whe defined above
enum day_of_week myday = TUESDAY; 
    \end{codeblock}
\end{frame}

\begin{frame}[fragile]{Enumerations in Switch Statements}
    Enumerations and switch statements often go hand in hand.
    They are also one of the cases where we can make good use of the
    fallthrough behaviour.
    \begin{codeblock}
switch(myday){
    case SATURDAY: 
    case SUNDAY: {
        puts("weekend :)");
    } break;
    default: {
        puts("its a weekday :("); 
    } break;
}
    \end{codeblock}
\end{frame}

\begin{frame}[fragile]{Structs}
    The basic building block of all data handling in C is the \code{struct}.
    Essentially it's just the idea to bundle up multiple variables as a reusable
    group. Like enums, structs are types and you can have variables of 
    that are \textbf{instances} of the struct.
    \begin{codeblock}
struct point{
    int x;
    int y;
}; // <- again, this trailing semicolon is necessary!

// this creates a variable called mypoint, which is an instance of
// the struct point
struct point mypoint;
    \end{codeblock}

    You can access elements of a struct using the \code{.} operator.
    \begin{codeblock}
mypoint.x = 3;
printf("\%i\n", mypoint.y);
    \end{codeblock}

    You can access elements of a struct using the \code{.} operator.
    \begin{codeblock}
mypoint.x = 3;
    \end{codeblock}
    
\end{frame}

\begin{frame}[fragile]{Shorthand Struct initialization}
    There exists a shorthand notation for creating instances of structs:
    \begin{codeblock}
struct point{
    int x;
    int y;
}; 

//this specifies the names explicitly
struct point myotherpoint = {x: 3, y: 5};

// this depends on the order of the struct members
struct point mypoint = {3, 5};
    \end{codeblock}

\end{frame}

\begin{frame}[fragile]{Structs and Enums in Functions}
    Structs and Enums can also be Function Parameters:
    \begin{codeblock}
void foo(enum day_of_week day, struct point p){ 
    //...
}
struct point p = {1,2};
//we can use enum values as literals, no need for a variable
foo(TUESDAY, p); 

// but this doesn't work, only use the struct shorthand
// for the initialization of variables !
foo(FRIDAY, {x: 1,y: 2}); //!!! compiler error
    \end{codeblock}
\end{frame}

//TODO(krbs): basic pointers

\begin{frame}[fragile]{Arrays}
    Structs are nice, but at the end of the day, why not just use multiple variables?
\end{frame}

\begin{frame}[fragile]{Nested Structs}
   \begin{itemize}
       \item Structs can be forward declared like functions: \code{struct foo;}
       \item But instances can't be declared or used before they are defined.
       \item 
            What works is declaring pointers to the forward declared struct.
            Since pointers have a constant size, the compiler doesn't need to
            know about the struct.
   \end{itemize}

    \begin{codeblock}
struct b;
struct a{
    //struct b bar; //! compiler error
    struct b* b_ptr; //works
};
struct b{
    struct a foo; //works, since a is defined
}
    \end{codeblock}

    These rules have the side effect of preventing an interesting case:
    What would be the size of \code{struct a} if line 3 was legal?
\end{frame}

\end{document}
