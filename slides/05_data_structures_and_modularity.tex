% document
\documentclass[10pt,graphics,aspectratio=169,table]{beamer}
\usepackage{../code}
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{pgfplots}
% theme
\usetikzlibrary{arrows}
\tikzstyle{line}=[draw] % here
\usetikzlibrary{decorations.pathmorphing}
\tikzset{arrow/.style={-latex, shorten >=.5ex, shorten <=.5ex}}

\usetheme{metropolis}
% packages
\title{Lesson 4}
\author{Christian Schwarz, Jakob Krebs}
\date{18.11.2019}
\begin{document}
\maketitle

\begin{frame}{Contents}
    \tableofcontents
\end{frame}


\section{Source Code and Solutions}
\begin{frame}{Sources and Solutions}
    \begin{itemize}
        \item we publish all code written in this course at \url{https://github.com/jkrbs/c_lessons}
        \item we will publish example solutions of the tasks on same site
        \item send us questions or your solutions to c-lessons@deutschland.gmbh
    \end{itemize}
\end{frame}

\section{Typedef}
\begin{frame}[fragile]{typedefs}
    In previous lessons we said that \code{size_t} or \code{bool} are not
    native to the C type system, but library types built upon it.
    But how do you define a type?
    
    \begin{codeblock}
typedef short tcp_port;

// we can now use tcp_port just like short:
void foo(){
    tcp_port x = 3;
    short y = 4;
    tcp_port z = x + y;
}
    \end{codeblock}

    Using typedefs we can give our types more domain specific meaning,
    helping somebody else who is using our code to understand. 
\end{frame}

\begin{frame}[fragile]{typedef with structs}
    In many other programming languages, 
    (including \code{C}'s bigger brother \code{C++}).
    We can use structs and enums just like the predefined types.
    So why do we have to write \code{struct foo} in \code{C}, instead of just
    \code{foo} ?. Well we don't \textbf{have} to.
    We can typedef our struct definition to be it's own type:
    \code{typedef struct foo foo;}. And we can combine this with the definition:
    \begin{codeblock}
// struct point is the struct name, can be used as normal
// the struct and typedef name can also be different
typedef struct point{ 
    int x, y; 
}point; //point now means the same as struct point

point add(point p1, point p2){
    point sum = {p1.x + p2.x, p1.y + p2.y};
    return sum;
}
    \end{codeblock}
\end{frame}
    \begin{frame}[fragile]{legacy code with unnamed structs}
    In old code the struct name is also left out:

    \begin{codeblock}
typedef struct{ 
    //point* p; //this wouldn't work
    int x, y; 
}point; 
// C++ compilers would complain about a type conflict here
// struct point;  
    \end{codeblock}

    This can cause problems in forward declarations and when you
    want to have pointers to the struct
    inside itself, since the typedef isn't available until the end.

    Therefore we don't do that.
\end{frame}
\end{document}
