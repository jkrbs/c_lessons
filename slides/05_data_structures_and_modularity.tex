% document
\documentclass[10pt,graphics,aspectratio=169,table]{beamer}
\usepackage{../code}
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{pgfplots}
% theme
\usetikzlibrary{arrows}
\tikzstyle{line}=[draw] % here
\usetikzlibrary{decorations.pathmorphing}
\tikzset{arrow/.style={-latex, shorten >=.5ex, shorten <=.5ex}}

\usetheme{metropolis}
% packages
\title{Lesson 5}
\author{Christian Schwarz, Jakob Krebs}
\date{25.11.2019}
\begin{document}
\maketitle

\begin{frame}{Contents}
    \tableofcontents
\end{frame}


\section{Source Code and Solutions}
\begin{frame}{Sources and Solutions}
    \begin{itemize}
        \item we publish all code written in this course at \url{https://github.com/jkrbs/c_lessons}
        \item we will publish example solutions of the tasks on same site
        \item send us questions or your solutions to c-lessons@deutschland.gmbh
    \end{itemize}
\end{frame}

\section{Typedef}
\begin{frame}[fragile]{typedefs}
    In previous lessons we said that \code{size_t} or \code{bool} are not
    native to the C type system, but library types built upon it.
    But how do you define a type?
    
    \begin{codeblock}
typedef short tcp_port;

// we can now use tcp_port just like short:
void foo(){
    tcp_port x = 3;
    short y = 4;
    tcp_port z = x + y;
}
    \end{codeblock}

    Using typedefs we can give our types more domain specific meaning,
    helping somebody else who is using our code to understand. 
\end{frame}

\begin{frame}[fragile]{typedef with structs}
    In many other programming languages, 
    (including \code{C++}).
    We can use structs and enums just like the predefined types.
    So why do we have to write \code{struct foo} in \code{C}, instead of just
    \code{foo} ?. Well we don't \textbf{have} to.
    We can typedef our struct definition to be it's own type:
    \code{typedef struct foo foo;}. And we can combine this with the definition:
    \begin{codeblock}
// struct point is the struct name, can be used as normal
// the struct and typedef name can also be different
typedef struct point{ 
    int x, y; 
}point; //point now means the same as struct point

point add(point p1, point p2){
    point sum = {p1.x + p2.x, p1.y + p2.y};
    return sum;
}
    \end{codeblock}
\end{frame}
    \begin{frame}[fragile]{legacy code with unnamed structs}
    In old code the struct name is also left out:

    \begin{codeblock}
typedef struct{ 
    //point* p; //this wouldn't work
    int x, y; 
}point; 
// C++ compilers would complain about a type conflict here
// struct point;  
    \end{codeblock}

    This can cause problems in forward declarations and when you
    want to have pointers to the struct
    inside itself, since the typedef isn't available until the end.

    Therefore we don't do that.
\end{frame}

\section{Macros}

\begin{frame}[fragile]{define}

We have talked about \code{#include<foo.h>}, which copies the content of foo.h into th file.

But we can define values which will be pasted into our code.

\begin{codeblock}
#define SIZE 10
#define PLAYER_CHAR '@'
#define PI 3.14159265
\end{codeblock}

everywhere we use \code{SIZE}, it will be replaced by th e preprocessor with \code{10}
\end{frame}

\begin{frame}[fragile]{ifdef}
there are some macros provided by our compiler, so we can detect our os:
\begin{codeblock}
#ifdef __linux__
    #include"your_linux_lib.h"
#elif _WIN32
    #include"your_windows_lib.h" 
#else
    //not supported
#endif
\end{codeblock}

here we check, if the macros \code{__linux__} or \code{_WIN32} exist.
\end{frame}

\begin{frame}[fragile]{header files}
when our projects become large, we want to split our code into multiple files.
But still our main file needs to know about all the functions. So we write the
signatures into a header file (fileending is \code{.h})

\begin{codeblock}
//foo.h

void do(int a, int b);
int some(struct point);
\end{codeblock}

and we can include this file by writing
\begin{codeblock}
#include "foo.h"
\end{codeblock}
in our c files, wehere we want to use those functions.
\end{frame}

\begin{frame}{other things in header files}
usually the follwing things are done in header files
\begin{itemize}
\item struct definitions
\item includes from external libraries
\item definition of macros
\end{itemize}
\end{frame}
\end{document}
